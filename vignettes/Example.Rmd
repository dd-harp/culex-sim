---
title: "Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(culex)
library(parallel)
library(data.table)
library(ggplot2)
```

Initial conditions and simulation time.

```{r}
parameters <- culex_parameters()

dt <- 0.1
tmax <- 365*3
maxstep <- tmax/dt

# initial # of adults
A0 <- c(600, 0)

# movement between 2 patches
psi <- matrix(
  data = c(0.95, 0.05,
           0.025, 0.975),
  nrow = 2, ncol = 2, byrow = TRUE
)
```

Now we need to integrate the ODEs describing maturation delays. We integrate them
past the last time step, because the value on the last time step is how long individuals
maturation at that time would have needed to wait (backwards-looking). We need the
time that individuals entering the stage at that time step need to wait before leaving
(forward-looking), so we subtract the delay from the time to get the entry times,
and pair those with the delay associated with entry into the stage at that time.

We use it to get 3 vectors, each one gives the number of time steps individuals
entering that stage on that step need to wait before maturation.

```{r}
# delays at t=0
tau0 <- c("E"=0,"L"=0,"P"=0,"EIP"=0)
temp0 <- temperature(0, parameters)
tau0[1] = 1 / egg_maturation_rate(temp0, parameters) # tau_E
tau0[2] = 1 / larvae_maturation_rate(temp0, parameters) # tau_L
tau0[3] = 1 / pupae_maturation_rate(temp0, parameters) # tau_P
tau0[4] = 1 / eip_rate(temp = temp0, parameters)

# integrate past the simulation end time by a comfortable amount
times <- seq(from=0.0,to=tmax+200,by=dt)
tau_ode <- deSolve::ode(y = tau0, times = times, func = tau_diffeqn, parms = parameters, method = "ode23")

tau_traj <- as.data.table(tau_ode)
tau_traj[, "EIP" := NULL]
tau_traj[, "step" := seq_along(times)]
# delays are now in units of time steps
tau_traj[, c("E", "L", "P") := lapply(.SD, function(x){as.integer(round(x = x/dt))}), .SDcols = c("E", "L", "P")]
tau_traj[, "time" := NULL]

# go from backward-looking maturation delays to forward-looking delays
tau_traj[, "step_forward_E" := as.integer(step - E)]
tau_traj[, "step_forward_L" := as.integer(step - L)]
tau_traj[, "step_forward_P" := as.integer(step - P)]
# the step_forward_X columns is the time step at which new X's need to wait
# tauX timesteps until going to the next stage. If the last row in any of
# them is < maxstep, we didn't integrate the ODEs far enough ahead.
tauE <- as.integer(tau_traj[step_forward_E %in% 1:maxstep, "E"][[1]])
tauL <- as.integer(tau_traj[step_forward_L %in% 1:maxstep, "L"][[1]])
tauP <- as.integer(tau_traj[step_forward_P %in% 1:maxstep, "P"][[1]])
```

Let's get a trajectory from the deterministic model with these initial conditions
and parameters.

```{r}
# solve a determiinistic trajectory
mod <- create_culex_deterministic(p = 2, tau_E = tauE, tau_L = tauL, tau_P = tauP, dt = dt, psi = psi)
set_A_deterministic(mod = mod, A = A0)

out_d <- data.table(day = rep(1:tmax, each = 8), stage = rep(c("E","L","P","A"), tmax*2), patch = rep(c(1,1,1,1,2,2,2,2), tmax), value = NaN)
setkey(out_d, "day")
out_d[, "patch" := as.factor(patch)]
out_i <- 1L

for (i in 1:maxstep) {
  step_culex_deterministic(mod = mod, parameters = parameters)
  if ((i-1) %% (1/dt) == 0) {
    out_d[day == out_i & stage == "E", "value" := as.vector(get_E_deterministic(mod))]
    out_d[day == out_i & stage == "L", "value" := as.vector(get_L_deterministic(mod))]
    out_d[day == out_i & stage == "P", "value" := as.vector(get_P_deterministic(mod))]
    out_d[day == out_i & stage == "A", "value" := as.vector(get_A_deterministic(mod))]
    out_i <- out_i + 1L
  }
}
```

We will draw 10 samples from the stochastic model.

```{r}
out <- parallel::mclapply(X = 1:10, FUN = function(runid) {
  mod <- create_culex_stochastic(p = 2, tau_E = tauE, tau_L = tauL, tau_P = tauP, dt = dt, psi = psi)
  set_A_stochastic(mod = mod, A = A0)

  out <- data.table(day = rep(1:tmax, each = 8), stage = rep(c("E","L","P","A"), tmax*2), patch = rep(c(1,1,1,1,2,2,2,2), tmax), value = NaN)
  setkey(out, "day")
  out[, "patch" := as.factor(patch)]
  out_i <- 1L

  for (i in 1:maxstep) {
    step_culex_stochastic(mod = mod, parameters = parameters)
    if ((i-1) %% (1/dt) == 0) {
      out[day == out_i & stage == "E", "value" := as.vector(get_E_stochastic(mod))]
      out[day == out_i & stage == "L", "value" := as.vector(get_L_stochastic(mod))]
      out[day == out_i & stage == "P", "value" := as.vector(get_P_stochastic(mod))]
      out[day == out_i & stage == "A", "value" := as.vector(get_A_stochastic(mod))]
      out_i <- out_i + 1L
    }
  }

  out[ , "run" := as.integer(runid)]
  return(out)
})
```

Plot the simulations.

```{r}
out_sum <- do.call(rbind, out)

ggplot(data = out_sum) +
  geom_line(aes(x=day, y =value, group = interaction(run, patch), color = stage, linetype = patch), alpha = 0.35) +
  geom_line(data = out_d, aes(x=day, y =value, color = stage, linetype = patch)) +
  facet_wrap(. ~ stage, scales = "free") +
  theme_bw()

ggplot(data = out_sum[stage == "A", ]) +
  geom_line(aes(x=day, y =value, group = interaction(run, patch), color = stage, linetype = patch), alpha = 0.35) +
  geom_line(data = out_d[stage == "A", ], aes(x=day, y =value, color = stage, linetype = patch)) +
  theme_bw()
```
